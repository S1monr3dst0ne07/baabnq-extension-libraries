
use 'libs/stack.baabnq';
use 'libs/float.baabnq';
use 'libs/chunk.baabnq';


jump Vec::Skip;

lab Vec::ModuleInit;
    sub Floats::ModuleInit;

    "vec<n> structure
    " _p + <i> -> component<i> :: Float
    "   ( where ∀i∈[0;n-1] )

    "size of the vector is also size of vec structure,
    "as a vector of size n will have n entries


    return;


"(N::Int) => (::Vec<N>)
lab Vec::Create;
    sub Stack::Swap;
    pull _size;

    new _size _pVec;

    push _pVec;
    push _Floats::Zero;
    sub Chunk::Fill;

    push _pVec;
    sub Stack::Swap;
    return;


"(::Vec<N>)
lab Vec::Delete;
    sub Stack::Swap;
    pull _pVec;

    free _pVec;
    return;

"(::Vec<N>) => (N::Int)
lab Vec::Dim;
    sub Stack::Swap;

    sub Chunk::Len;

    sub Stack::Swap;
    return;




"(A::Vec<N>, B::Vec<M>) => (Size::Int)
"Size = N == M ? N : 0
lab Vec::VerifyDims;
    sub Stack::Swap;
        sub Vec::Dim;
        pull _n;
    sub Stack::Swap;
        sub Vec::Dim;
        pull _m;

    push 0;
    push _n;
    sub Stack::Swap ~ _n == _m;
    pull __;

    sub Stack::Swap;
    return;



lab Vec::Iter;
"   Vec::Iter<A> (where A∈{Bin, Uni})
"   is a system that effectively functions as a compile-time closure.
"   is does so, by modifying the stack-frames of meta routines,
"   causing them to, instead of returning their meta routine, jumps back
"   to an earlier part of the routines, inducing a loop.
"   this virutal looping behavior is exploited to iterate over the vector.
    return; 

lab Vec::IterBin::Register;
    pull _aMesa;
    pull _aMeta;

        pull _pCompAuxil;
        pull _pCompCumul;

        push _pCompCumul;
        push _pCompAuxil;
        sub Vec::VerifyDims;
        pull _i;

    push _aMeta;
    push _aMesa;
    return;


"return addresses are included in signature
"   (Mesa::Address) => (
"       LoopStart::Address,
"       CumulComponent::Int,
"       AuxilComponent::Int,
"       Mesa::Address
"   )
lab Vec::IterBin::Begin;
    pull _aMesa;

    "address of start of loop,
    "which is used to continue to loop
    push _aMesa - 1;

    "update loop index
    put _i = _i - 1;

    "construct in-frame for vector operation
    put _cumul <- _pCompCumul + _i; push _cumul;
    put _auxil <- _pCompAuxil + _i; push _auxil;

    push _aMesa;
    return;

"(Mesa::Address, Loop::Address) => (Target::Address)
"Target::Address = LoopIndex > 0 ? Loop::Address : Mesa::Address
lab Vec::IterBin::End;
    pull _aMesa;

    "deconstruct out-frame for vector operation
    pull _cumul; put _cumul -> _pCompCumul + _i;

    "pull loop address
    pull _aLoop;

    "continue loop if index is bound
    push _aMesa;
    push _aLoop; 
    sub Stack::Swap ~ _i > 0;
    pull __;
    return;

    

"(Cumulator::Vec, Addend::Vec)
lab Vec::Add;
    sub Vec::IterBin::Register;
    
    sub Vec::IterBin::Begin;
        sub Floats::Add;
    sub Vec::IterBin::End;

    return;





lab Vec::Skip;
