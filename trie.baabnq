
use 'libs/stack.baabnq';
use 'libs/no.baabnq';


sub Trie::ModuleInit;

jump Trie::Skip;


lab Trie::ModuleInit;
    "trie structure
    " _p + 0 -> sub :: Chunk[16]
    " _p + 1 -> end :: Bool

    "sub contains the references to sub nodes.
    "end indicates whether node constitudes a sequence or not.

    "a trickle is a sequence of nibbles,
    "and is the type of sequence that this trie implementation uses.
    "this is the case, because 16 entires per nodes strikes a good balance.


    put _Trie::Trie::SUB = 0;
    put _Trie::Trie::END = 1;

    return;


"=> (::Trie)
lab Trie::Allocate;
    new 2 _pTrie;

    push _pTrie;
    sub Stack::Swap;
    return;


"=> (::Trie)
lab Trie::Create;
    sub Trie::Allocate;
    pull _pTrie;

    new 16 _pSub;
    put _pSub -> _pTrie + _Trie::Trie::SUB;

    push _pTrie;
    sub Stack::Swap;
    return;


"(::Trie)
lab Trie::Delete;
    sub Stack::Swap;
    pull _pTrie;

    sub No::Return ~ _pTrie == 0;

    put _pSub <- _pTrie + _Trie::Trie::SUB;
    free _pTrie;

    lab Trie::Delete::Loop;
        put __ <- _pSub + _i;
        put _i = _i + 1;

        push _i;
        push _pSub;
            push __;
            sub Trie::Delete;
        pull _pSub;
        pull _i;
    jump Trie::Delete::Loop ~ _i < 5;

    return;


"(::Chunk) => (::Trickle)
lab Trie::ChunkToTrickle;
    sub Stack::Swap;
    pull _pChunk;

    push _pChunk; sub Chunk::Len; pull _chunkLen;
    put _trickleLen = _chunkLen << 2; "4 nibbles per word, ergo multiply by 4

    new _trickleLen _pTrickle;

    put _i = 0;
    lab Trie::ChunkToTrickle::Loop;
        put _chunk <- _pChunk + _i;

        put __ = _i << 2;
        put (_chunk >> 12) & 15 -> _pTrickle + __ + 0;
        put (_chunk >> 08) & 15 -> _pTrickle + __ + 1;
        put (_chunk >> 04) & 15 -> _pTrickle + __ + 2;
        put (_chunk >> 00) & 15 -> _pTrickle + __ + 3;

        put _i = _i + 1;
    jump Trie::ChunkToTrickle::Loop ~ _i < _chunkLen;

    push _pTrickle;
    sub Stack::Swap;
    return;


"(::Trie, ::Trickle)"
lab Trie::InsertTrickle;
    sub Stack::Swap; pull _pTrickle;
    sub Stack::Swap; pull _pTrie;

    push _pTrickle; sub Chunk::Len; pull _trickleLen;
    jump Trie::InsertTrickle::BaseCaseSkip ~ _trickleLen != 0;
        put 1 -> _pTrie + _Trie::Trie::END;
        return;
    lab Trie::InsertTrickle::BaseCaseSkip;

    "save original trie
    push _pTrie;

    put _pSubs <- _pTrie + _Trie::Trie::SUB;
    put _char <- _pTrickle;
    put _pSubAddr = _pSubs + (_char & 15);
    put _pSubTrie <- _pSubAddr;
    jump Trie::InsertTrickle::NewSubTrieSkip ~ _pSubTrie != 0;
        sub Trie::Create;
        pull _pSubTrie;
        put _pSubTrie -> _pSubAddr;
    lab Trie::InsertTrickle::NewSubTrieSkip;

    "now, it's time to unwrap the trickle
    "this is a programming trick, straight from the forbidden books

    "save current ctx
    push _pTrickle;
    push _char;

    "rebase length prefix (this is the unwrapping part)
    put _trickleLen -> _pTrickle;

    push _pSubTrie;
    push _pTrickle + 1;
    sub Trie::InsertTrickle;

    "restore ctx
    pull _char;
    pull _pTrickle;
    pull _pTrie;

    "change length prefix back to content (wrapping things up again)
    put _char -> _pTrickle;

    return;







lab Trie::Skip;


