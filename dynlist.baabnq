
use 'libs/stack.baabnq';
use 'libs/chunk.baabnq';


"list structure
" _p+0 -> size      :: Int
" _p+1 -> container :: Chunk

"capacity is stored by container, because it's a chunk

put _DynList::List::SIZE       = 0;
put _DynList::List::CONTAINER  = 1;







jump DynList::Skip;


"=> (::DynList)
lab DynList::Allocate;    
    new 2 _pList;

    push _pList;
    sub Stack::Swap;
    return;

"(Size::Int, Container::Chunk) => (::DynList)
lab DynList::CreatePopulate;
    sub Stack::Swap; pull _pContainer;
    sub Stack::Swap; pull _size;

    sub DynList::Allocate;
    pull _pList;
        
    put _size       -> _pList + _DynList::List::SIZE;
    put _pContainer -> _pList + _DynList::List::CONTAINER;

    push _pList;
    sub Stack::Swap;
    return;


"(Container::Chunk) => (::DynList)
lab DynList::CreatePopulateInferSize;
lab DynList::CreateUseChunk;
    sub Stack::Swap;
    pull _pContainer;

    push _pContainer;
    push _pContainer;
    sub Chunk::Len;
    sub DynList::CreatePopulate;

    sub Stack::Swap;
    return;


"=> (::DynList)
lab DynList::CreateEmpty;
lab DynList::Create;
    new 0 _pContainer;

    push _pContainer;
    sub DynList::CreatePopulateInferSize;

    sub Stack::Swap;
    return;



"(::Chunk) => (::DynList)
lab DynList::CreateCopyChunk;
    sub Stack::Swap;

    sub Chunk::Copy;
    sub DynList::CreatePopulateInferSize;
    
    sub Stack::Swap;
    return;


"(::DynList) => (::DynList)
lab DynList::CreateCopyList;
lab DynList::Copy;
    sub Stack::Swap;
    
    sub DynList::Container;
    sub Chunk::Copy;
    sub DynList::CreatePopulateInferSize;

    sub Stack::Swap;
    return;
    







"(::DynList)
lab DynList::Delete;
    sub Stack::Swap;
    pull _pList;

    put _pContainer <- _pList + _DynList::List::CONTAINER;
    free _pContainer;
    free _pList;
    
    return;    





"(::DynList) => (Empty::Bool)
lab DynList::IsEmpty;
    sub Stack::Swap;
    sub DynList::Size;
    pull _size;
    
    jump DynList::IsEmpty::False ~ _size == 0; push 0; lab DynList::IsEmpty::False;
    jump DynList::IsEmpty::True  ~ _size != 0; push 1; lab DynList::IsEmpty::True;
    
    sub Stack::Swap;
    return;


"(::DynList) => (Size::Int)
lab DynList::Size;
    sub Stack::Swap;
    pull _pList;

    put _size <- _pList + _DynList::List::SIZE;

    push _size;
    sub Stack::Swap;
    return;


"(::DynList) => (Container::Chunk)
lab DynList::Container;
lab DynList::Data;
lab DynList::Pointer;
    sub Stack::Swap;
    pull _pList;

    put _size <- _pList + _DynList::List::CONTAINER;

    push _size;
    sub Stack::Swap;
    return;



"(::DynList,  Capacity::Int)
lab DynList::Reserve;
    sub Stack::Swap; pull _capacitiyNew;
    sub Stack::Swap; pull _pList;

    push _pList; sub DynList::Container; pull _pContainerOld;
    push _pContainerOld; sub Chunk::Len; pull _capacitiyOld;


    "capacity already reserved
    sub No::Return ~ _capacitiyNew <  _capacitiyOld;
    sub No::Return ~ _capacitiyNew == _capacitiyOld;

    "alloc new container
    new _capacitiyNew _pContainerNew;

    "copy old to new
    push _pContainerOld;
    push _pContainerNew;
    push _capacitiyOld;
    sub String::MemCpy;

    "free old
    free _pContainerOld;

    "inject new container into list
    put _pContainerNew -> _pList + _DynList::List::CONTAINER;

    return;





lab DynList::Skip;



